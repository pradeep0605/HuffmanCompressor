
/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}



/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}

/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}



/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}

/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}



/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}

/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}



/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}




/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
  
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return( (unsigned char)ch);
}


void writeCompressedCode(ofstream &,ifstream &,String *,unsigned int);

int main(int argc, char *argv[])
{  
  
      if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
   unsigned int fileSize=0,fileSizeTemp;
   ifstream in(argv[1],ios::binary);
   in.seekg(0,ios::end);
   fileSize=in.tellg();
   fileSizeTemp=fileSize;
   in.seekg(0,ios::beg);
   unsigned int arr[256];

   for(int i=0;i<256;i++)
     arr[i]=0;

   unsigned char ch;
   unsigned long int nobytes=0;

   while(fileSizeTemp>0)
   {
      in.read((char*) &ch,sizeof(char));
      arr[(unsigned int)ch]++;
      fileSizeTemp--;
   }

   in.close();

   
   unsigned int properCount=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
     {
           properCount++;
          // cout<<" |"<<arr[i]<<","<<char(i)<<"| ";
     }
   }
   

 /*  node roots[properCount]; 
   int k=0;

   for(int i=0;i<256;i++)
   {                         
     if(arr[i]!=0)                  
     {                                      
       roots[k]=node(arr[i],(unsigned char)i);                 
       k++;                                        
     }                                        
   }                 
   */
   //node *ROOT=constructTree(roots,properCount);
   
 
   String code[256];
 
   generateCodes(arr,code,properCount);
 
   /*
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
  */

   /*long double no_of_bits=0;
   double no_of_comp_bytes=0;
   unsigned char no_of_rem_bits=0;
   
   for(int i=0;i<255;i++)
   {
     if( code[i].getLength()>0)
     {
       no_of_bits= no_of_bits + (arr[i] * code[i].getLength());
       //cout<<char(i)<<" : "<<code[i]<<endl;
     }
   }
  

   no_of_comp_bytes=no_of_bits/8;
   no_of_rem_bits=long (no_of_bits) % 8;  
   
   cout<<"Total compressed bytes :"<<(unsigned long)no_of_comp_bytes<<endl;
   cout<<"Remaining bits :"<<(int)no_of_rem_bits<<endl;*/

   in.close();
   ifstream ins;
   ins.open(argv[1],ios::binary);
   ins.seekg(0,ios::beg);
   ofstream out(strcat(argv[1],".pkr"),ios::binary);  
   
   
   unsigned char indexes[properCount];
   unsigned int  array[properCount];
   int k=0;
   for(int i=0;i<256;i++)
   {
     if(arr[i]>0)
      {
          indexes[k]=(unsigned char)i;
          array[k]=arr[i];
          k++;
      }
   } 
   Table t=Table(array,indexes,properCount,(unsigned int)fileSize);
   t.writeToFile(out);
   //t.display();
   
   writeCompressedCode(out,ins,code,fileSize);
   
}



  void writeCompressedCode(ofstream &out,ifstream &in,String *code,unsigned int fileSize)
  {
    unsigned int originalSize=fileSize;
    char *finalCode=new char[50];
    unsigned long writtenBytes=0;
    for(int i=0;i<50;i++)
           finalCode[i]='\0';
    unsigned char ch=65;
    bitset <8> b;

    while(fileSize >= 1)
    {
    
        while(strlen(finalCode) <8 && fileSize>0)
        {
          in.read((char*)&ch,1);
          fileSize--;
          /*if(fileSize%999==0)
              cout<<"\r"<< float(originalSize-fileSize)/originalSize*100<<" %";*/
          strcat(finalCode, code[(unsigned int)ch].str);
        }
       
       while(strlen(finalCode)>=8 )
       {
          for(int i=0;i<8;i++)
          { 
             b[7-i]=int(finalCode[i])-48;
          }

          ch=toChar(b);
          out.write((char *) &ch,sizeof(unsigned char));
          out.flush();
          writtenBytes++;
          strcpy(finalCode,&finalCode[8]);
       }
    }
    while(strlen(finalCode)>=8)
    {
      for(int i=0;i<8;i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;
      strcpy(finalCode,&(finalCode[8]));
    } 
      
      for(int i=0;i<strlen(finalCode);i++)
      { 
         b[7-i]=int(finalCode[i])-48;
      }
      ch=toChar(b);
      out.write((char *) &ch,sizeof(unsigned char));
      writtenBytes++;    
      strcpy(finalCode,&(finalCode[8]));
      cout<<endl<<"WRITTEN BYTES:"<<writtenBytes<<endl;
      cout<<endl<<"rem bits :"<<strlen(finalCode);
  }    













/* For performance improvement I cant do the following things
  1. better sorting alogrith thatn quick sort.
  2. Or to eliminate sorting.
  3. Have least access to the hard disk as it increases the execution time.
  4. Remove as many couts as possible.
  5. Remove waste  code.
  */
#include<iostream>
#include<fstream>
#include<bitset> 
#include "treeGenerator.cpp"

using namespace std;

unsigned long int bytesDetected=0;

class Table
{
   public:
   unsigned short indicesSize;
   unsigned char  *indexes;
   unsigned int   *arr;
   unsigned int   no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned char[size];
     arr=new unsigned int[size];
   }

   Table(unsigned int *,unsigned char *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned char));
       out.write((char *)       arr, indicesSize*sizeof(unsigned int));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned char));
       in.read((char *)       arr, indicesSize*sizeof(unsigned int));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned int a[],unsigned char c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned int[arraySize];
   indexes=new unsigned char[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}


using namespace std;

bitset <8> toBits(unsigned char ch)
{
   return bitset<8>(ch);
}

unsigned char toChar(bitset <8> b)
{
  short ch=0;
  for(int i=7;i>=0;i--)
  {
     ch=ch<<1;
     ch=ch+short(b[i]);
  }
  return char(ch);
}

void writeDecompressedCode(ofstream &,ifstream & ,String *,unsigned int, node *);

int main(int argc, char *argv[])
{  
  	
   if(argc<2)
   {
     cout<<"Improper arguments";
     return 0;
   }
    
    Table t=Table(256);
    ifstream in(argv[1],ios::binary);
    t.readFromFile(in);
    //t.display();
    
    unsigned int arr[256];
     node roots[t.indicesSize];
    
    for(int i=0;i<t.indicesSize;i++)
    {
       arr[(unsigned int) t.indexes[i]]=t.arr[i];
       roots[i]=node( arr[(unsigned int) t.indexes[i]], t.indexes[i]);
    }    
    
   node *ROOT=constructTree(roots,t.indicesSize);
    
   String code[256];
   generateCodes(ROOT,code);
   
   /*    
   for(int i=0;i<256;i++)
   {
      if(code[i].getLength()>0)
      {
         cout<<(unsigned char)i<<":"<<code[i]<<endl;
      }
   }
   */
   
   char *folder=new char[50];
   strcpy(folder,"mkdir ");
   String temp=String(argv[1]);
   temp=temp.subString(0,temp.getLength()-5);
   strcat(folder,temp.str);
   strcat(folder,".pkrout");
   system(folder);

   strcpy(folder,&(folder[6]));
   strcat(folder,"/");
   strcat(folder,temp.str);
   ofstream out(folder,ios::binary);
   
   writeDecompressedCode(out,in,code,t.no_bytes,ROOT);
   cout<<endl<<"Bytes Detected:"<<bytesDetected;
}


String toString(bitset <8> b)
{
  String temp(10);
  for(int i=0;i<8;i++)
  {
    temp.str[i]= (unsigned char) (b[7-i] +48);
  }
  return temp;
}


int getDecompressedChar(String &s,node *ROOT)
{
   node *temp;
   temp=ROOT;
   int k=0;
   
   while(s.getLength()>0)
   {
        if(temp->lchild == null && temp->rchild==null)
        {  
           strcpy(s.str,&(s.str[k]));
           bytesDetected++;
           return ((unsigned int) temp->ch);
        }  
        else
        {
           if(s.str[k]=='\0')
                return -1;
                
           if(s.str[k]=='0')
           {
              temp=temp->lchild;
              k++;
           }
           else
           {
              temp=temp->rchild;
              k++;
           }
        }  
      
   }
   return -1;
}


void writeDecompressedCode(ofstream &out,ifstream &in ,String code[],unsigned int nobytes, node *ROOT)
{
     unsigned char ch=0;
     int i=0;
     String s(5000);
     for(int i=0;i<100;i++)
         s.str[i]='\0';
         
     s.str[0]='\0';
     bitset <8> b;
      while(!in.eof())
      {
         ch=in.get();
         b=toBits(ch);
         s=s+toString(b);
         
         i=getDecompressedChar(s,ROOT);
         while(i!=-1 && nobytes>0)
         {
           ch=(unsigned char)i;
           out.write((char *) & ch , sizeof(unsigned char));
           nobytes--;
           i=getDecompressedChar(s,ROOT);
         }
         //continue
      }
}






#include<iostream>
#include "tree.cpp"

using namespace std;
/*
int root_partition(node *, int, int);


void rootSort(node arr[],int l,int r)
{
   if(l<r)
   {
      int p=root_partition(arr,l,r);
      rootSort(arr,l,p-1);
      rootSort(arr,p+1,r);
   }
}

int root_partition(node a[],int l,int r)
{   
   int i=0,j=0;
   node pivot=a[l];
   i=l+1;
   j=r;
   while(i<=j)
   { 
      while(a[i].value<=pivot.value && i<r)
      {
         i++;
      }
      while(a[j].value>=pivot.value && j>l)
      {
         j--;
      }
      if(i<j)
      {
         node *temp=new node();
         *temp=a[i];
         a[i]=a[j];
         a[j]=*temp;
         continue;
      }
      else
      {
         break;
      }
   }
   a[l]=a[j];
   a[j]=pivot;
   return j; 
}*/


unsigned int * get2LeastIndexes(node arr[],unsigned int n)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0;
   for(int i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value!=0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   unsigned int *indexes=new unsigned int [2];
   indexes[0]=index1;
   indexes[1]=index2;
   return indexes;
}

node *  constructTree(node arr[],unsigned int n)
{ 
    int k=0,i,j;
    unsigned int firstIndex=0,secondIndex=0;
    unsigned int *indexes=new unsigned int[2];
    while(k<n)
    {   
      
        indexes=get2LeastIndexes(arr,n);
        
        firstIndex=indexes[0];
        secondIndex=indexes[1];
        
        /*for(int i=0;i<n;i++)
        { 
           cout<<"|"<<(unsigned short)i<<":"<<arr[i].value<<"|  ";
        }
        cout<<endl;
        cout<<"firstINdex:"<<firstIndex<<"  secondIndex:"<<secondIndex<<endl<<endl;
        */
        node *left=new node(arr[firstIndex]);
        node *right=new node( arr[secondIndex] ); 
        left->leaf=true;
        right->leaf=true;
        
        arr[firstIndex]=node();
             
        arr[secondIndex].lchild=left;
        arr[secondIndex].rchild=right;
        arr[secondIndex].value=left->value+right->value;
        arr[secondIndex].ch=-1;
        arr[secondIndex].leaf=false;
        k++;
    }
    
    return &arr[secondIndex];
}






/*This program includes 
   1. Operator overloading for reading and writing an object from console
   2. Multiple types of constructors
   3. Dynamic memory allocation
   4. Illustration of THIS pointer
   5. Nesting of member functions
   6. Anonymous object creation.  (NOt possible in turbo c++)
   7. Writing of String object to file as text.
   8. Error handling. Exception handling (NOt possible in turbo c++)
   9. Function overloading
  10. Conversion from class to basic 
  11. Conversion from basic to class
  12. single Operator cascading.
  13. Multiple Operator cascading. 
  14. Extensive string hadling functions defined.
*/

#include<iostream>
#include<fstream>
#include<cstring>
#include<cstdlib>
#include<exception>

using namespace std;

class String
{
  short length;
  int    find(String,char);					 //Stores the length of the string

  public:
    char *str;                    		 //Character array
    String *next;
    char index;
     //Default constructor
     //default delimiter is newline character. i.e Reads the string till the new 
     String()
     {
       index=0;
       length=30;
       next=NULL;
       str=new char[length+1];
       str[0]='\0';
     }
     
     //constructor which constructs(memory allocation) the string with the specified no of character size.
     String(int size)
     {
       length=size;
       str=new char[length+1];
     }
     
     //Constructor what takes String literals to construct the object. 
     String(char *s)
     {
       length=strlen(s);
       str=new char[length+1];
       strcpy(str,s);
     }
     
     //this funtion sets the deliminter for reading the string from the key borad
     
     //Retruns the length of the String object. (no of character exculding '\0' character
     int getLength()
     {
        this->length=strlen(str);
        return length;
     }
     
     //WRITING STRING TO CONSOLE "<<" overloaded
     friend ostream & operator <<(ostream &out,String s)
     {
          out<<s.str;
          return out;       
     }
     
     //WRITING STRING TO FILE 
     friend ofstream& operator <<(ofstream &out, String s)
     {
        out<<s.str;
        return out; 
     }     
     
     //READING STRING FROM FILE
     friend ifstream & operator >>(ifstream &fin,String &s)
     { 
         s=String(1024);
         fin>>s.str;
         return fin;
     }

     //Converts the string object to character array (Returns the address of the pointer which points to the
     //                                               beggining of the character array)                         
     char * toCharArray()
     {
        return str;
     }

     //SUBSTRING 1 TYPE (which gives string from the specified location till the end of string)
     String subString(int index)
     {
       if(index>strlen(str)|| index<0)
       {
         throw ("Array out of bound exception!"); // if index is out of range(array bound cheking).
       }
       return *new String(&str[index]);
     }
     
     
     //SUBSTRING 2 TYPE (which gives the substring from the specified starting location 
     //		         to the location specified by the "end" variable			
     String subString(int start,int end)
     {
       if( start<0 || end>strlen(str) -1 || start>end)
       {
         throw ("Array out of bound exception!");//Array bound cheking.
       }
      
       String s(this->getLength());
       strcpy(s.str,str);
       s.str[end+1]='\0';
       s.str=&s.str[start];
       return s;
     }
     
     // Function prototypes for which definition is available outside the class.     
     friend istream & operator >>(istream &in,String &s);
     operator int();    
     String operator + (char *);
     String operator + (String);
     String operator - (char *);
     String operator - (String);
     int   toInteger();
     void   operator =(int);
     String * tokenize(char,int&);  
     int indexOf(String );
     String trim(char ch=' ');
};

   //Function for searching a string in the text..
   int String::indexOf(String pattern)
   {   int j=0;
       if(pattern.getLength() > this->getLength())
       {
          return -1;      // Error that the text to be searched cannot be more than the text.
       }
        for(int i=0;i<=this->getLength()-pattern.getLength();i++)
        {
           j=0; //To start searching pattern in the text from beggining of pattern.(text inedex is continued).
           while(str[i]==pattern.str[j] && j<pattern.getLength())//till characters are successively found and till j< patterns's length
           {
             i++;
             j++;
           }         
           if(j==pattern.getLength())
           {
             return i-j; //return the location where the character found.
           }
          
        }
      return -1;  //NO match found 
   }
   
    // This function is used to remove the unwanted character and tabspace 
    //    before and after the string. (it also removes the tab spaces in between the text, but not the spaces *)...
   String String:: trim(char ch)
   {
      String temp=*this;
      for(int i=0;i<temp.getLength();i++)
      {     
          
            if(temp.str[i]=='\t')
            {
              temp.str[i]=ch;          //replacing tabspace by single space.
            }
      }
      int beg=0;
      char chr=temp.str[beg];
      while(chr==ch)    // This code(while part) is used to remove the blank spaces at the beggining.
      {
        beg++;
        chr=temp.str[beg];  
       }
      temp=temp.subString(beg);
      
      int end=temp.getLength()-1;
      chr=temp.str[temp.getLength()-1];
      while(chr==ch) // Used to remove the blank spaces at the end.
      {
        end--;
        chr=temp.str[end];
      }   
      temp=temp.subString(0,end);
      *this=temp;
      return *this;
   }
   
   
   // One of the most widely used string fucntions
   /* This function is used to tokenize(create fragments or parts) the given string    
      into array of string with the given deliminter. i.e "ch" here. (excluding delimiter).
   */
   String *  String:: tokenize(char ch,int &n)
   {
      String temp(this->getLength());
      strcpy(temp.str,this->str);
      temp.trim(ch);
      int count=0,j=0,i,k;
      int indexes[temp.getLength()];
      for(i=0;i<temp.getLength();i++)
      {
        if(temp.str[i]==ch)
        {
          count++;
          indexes[j]=i;          //count the number of occurance of the delimiter.
	  j++;
        }
      }
      indexes[j]=temp.getLength()-1;//assign even the last character's index.
      
      String *token=new String[count];//create array of string for the number of tokens.
      
      for(k=0;k<=j;k++)
      { 
        try
        {
         if(k==0)
         {
            token[k]=temp.subString(0,indexes[k]-1);        // assign the string(as token) from begging to the first occurance
         }                                                  // of the delimiter.
         else
         if(k==j)
         {
           token[k]=temp.subString(indexes[k-1]+1,indexes[k]); //assign the string from last occurance of the delimiter till the end
         }
         else
         {
            token[k]=temp.subString(indexes[k-1]+1,indexes[k]-1);//assign the string b/w two deliminters.
         }
        }
        catch(const char *s)
        {} 
      }
     //There will be many occurance of successive delimiters. So for them empty tokens will be
     // create. SO they should be removed.      
     int fin_count=0;
     
     for(k=0;k<=j;k++)
     {
        if(token[k].getLength()!=0)
        {
          fin_count++;   //count only the tokens which have length more thatn 0.
        }
     }
       
     String *fin_token=new String[fin_count]; //create array of string only for the valid tokens. 
     i=0;
     for(k=0;k<=j;k++)
     {
       if(token[k].getLength()!=0)
       {
          fin_token[i]=token[k];
          i++;
       }
     }
     n=fin_count;
     return fin_token;
   }
   
    //Conversion from basic to class type
    void String::operator=(int i)
   {
      String temp=String(13);
      int rev=0,mul=10;
      
      while(i!=0)
      {
         if(!((i%10)+48)>=48 &&  ((i%10)+48)<=57) //cheking whether the character is not b/w 30h and 39h, if so throw the error.
         {
    	    throw("Conversion exception\n Invalid character occurance while conversion\n");
         }
         rev= (rev*mul) + (i%10);
         i/=10;
      }
       i=0;
      while(rev!=0)
      {
        temp.str[i]= char((rev%10) + 48); //converts integer to string.
        rev/=10;
        i++;
      }
      
      temp.str[i]='\0';
      
      *this=temp;
   }       
   //converts from string to integer.
   int String :: toInteger()
   {
       char *temp=str;
       int res=0,mul=1;
       while(*temp!='\0')
       {
         temp++;
       }
       temp--;
       
       while(temp!=(str-1))
       {
          if(int(*temp==7))
          {
            temp--;
            continue;
          }
          if( int(*temp) <48 || int(*temp) >57) //checking for non numerical character if found throw an exception.
          {
            throw ("Invalid string to integer conversion\n Invalid characters found\n");
          }
          else
          {
             res=res+ mul*(int(*temp)-int('0'));
             mul*=10;
          }
          temp--;
       }
	
	return res;
   }
   
   
   String :: operator int()
   {
       return this->toInteger();
   }
   
  //For string concatination with string literal 
 String String:: operator + (char *s)
{ 
  char *temp=str;
  str=new char[strlen(str)+strlen(s)+1];
  strcpy(str,temp);
  strcat(str,s);
  return *this; 
}

//For String concatination with another string object.
String String:: operator +(String s)
{
 /*char *temp=str;
  str=new char[strlen(str)+strlen(s.str)+1];
  strcpy(str,temp);*/
  strcat(str,s.str);
  return *this;
}


//For deleting the character that are there in *s from the string object
String String::operator -(char *s)
{
  String temp(this->getLength());
  int j=0;
  
  String del(s);
  
    for(int i=0;i<this->getLength();i++)
    {
        if(find(del,str[i]))
        {
          continue;
        }     
        else
        {
           temp.str[j]=str[i];
           j++;  
        }
    }
    temp.str[j]='\0';
    temp.length=strlen(temp.str);
  return temp;
}

//Finds a character in a given string. (used for only internal operational purpose and is hidden to user.
//As they have indexOf function for searching.
int String:: find(String s,char ch)
{
  
    for(int i=0;i<s.getLength();i++)
    {
       if(s.str[i]==ch)
          return 1;
    }
    return 0;
}

//For deleting the character that are there in string object s from the string object
String String::operator -(String s)
{
 return *this- s.str; // NEsting of member functions
}#include<iostream>
#include<fstream>

using namespace std;



class Table
{
   public:
   unsigned short  indicesSize;
   unsigned short  *indexes;
   unsigned short  *arr;
   unsigned int    no_bytes;
   Table()
   {
      indicesSize=0;
      no_bytes=0;
   }

   Table(int size)
   {
     indexes=new unsigned short[size];
     arr=new unsigned short[size];
   }

   Table(unsigned short *,unsigned short *,unsigned int,unsigned int);
   
   void display();
   void writeToFile(ofstream &out);
   void readFromFile(ifstream &in);
};

   void Table::writeToFile(ofstream &out)
   {
       out.write((char *) &indicesSize,sizeof(indicesSize));
       out.write((char *)   indexes, indicesSize*sizeof(unsigned short));
       out.write((char *)       arr, indicesSize*sizeof(unsigned short));
       out.write((char *) &no_bytes,sizeof(no_bytes));
   } 
   
   void Table::readFromFile(ifstream &in)
   {
       in.read((char *) &indicesSize,sizeof(indicesSize));
       in.read((char *)   indexes, indicesSize*sizeof(unsigned short));
       in.read((char *)       arr, indicesSize*sizeof(unsigned short));
       in.read((char *) &no_bytes,sizeof(no_bytes));
   }
   
   
Table::Table(unsigned short a[],unsigned short c[],unsigned int arraySize,unsigned int no_bytes)
{
   arr=new unsigned short[arraySize];
   indexes=new unsigned short[arraySize];
   indicesSize=(unsigned short)arraySize;
   this->no_bytes=no_bytes;
     
   for(int i=0;i<arraySize;i++)
   {
      arr[i]=a[i];
      indexes[i]=c[i];
   }  
}


void Table:: display()
{
   cout<<"Size:"<<indicesSize<<endl;
   for(int i=0;i<indicesSize;i++)
   {
      cout<<"|"<<int(indexes[i])<<","<<arr[i];
   } 
    cout<<endl<<"No.bytes:"<<no_bytes<<endl;
}
#include<iostream>
#include<string.h>

using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
   s[k]='\0';
}

int main()
{
   char str1[100],str2[200];
   cout<<"Enter the string:";
   cin>>str1;
    strrev(str1);
   cout<<"\nREverse string is:"<<str1<<endl;
   return 0;
}

#include<iostream>
#include "string.cpp" 

#define null 0

using namespace std;

class node
{
   public:
   unsigned int value;
   unsigned char ch;
   node * lchild, * rchild;
   
   node()
   {
     ch=0;
     value=0;
     lchild=rchild=null;
   }
   
   node(unsigned int value,unsigned short ch)
   {
      this->value=value;
      this->ch=ch;
      lchild=null;
      rchild=null;
   }
   
   node(node &n)
   {
      value=n.value;
      ch=n.ch;
      lchild=n.lchild;
      rchild=n.rchild;
   }
   
};


char *codeGen=new char[50];
int codeIndex=0;

void generateCodes(node *root,String *codes)
{
   if(root->lchild!=null)
   {
     codeGen[codeIndex]='0';
     codeIndex++;
     generateCodes(root->lchild,codes);
   }
   
   if(root->rchild!=null)
   {
     codeGen[codeIndex]='1';
     codeIndex++;
     generateCodes(root->rchild,codes);
   }
   
   if(root->lchild==null && root->rchild==null)
   {
      //cout<<root->ch<<endl;
      codes[(unsigned int)root->ch]=codeGen;
   }
   
    codeGen[codeIndex]='\0';
    codeIndex--;   
}







#include<iostream>
#include "tree.cpp"
#include<cstring>


using namespace std;

void strrev(char *s)
{
   short tp=0;
   char temp[tp=strlen(s)];
   strcpy(temp,s);
   int k=0;
   for(int i=tp-1;i>=0;i--)
   {
     s[k++]=temp[i];
   }
//   s[k]='\0';
}

class group
{
   public:
   int value; //groupValue
   String *start, *end;
   group()
   {
      value=0;
      start=end=NULL;
   }
   void add(String *s,int value)
   {
       start=end=s;
       s->next=NULL;
       this->value=value;
   }
   
   void append(char ch)
   { 
       String *temp=start;
       while(temp!=NULL)
       {
           temp->str[temp->index++]=ch;
           temp=temp->next;
       }
   }
   
   void display()
   {
       String *temp=start;
       while(temp!=NULL)
       {
          //cout<<"|"<<temp->str<<"|  ";
          temp=temp->next;
       }
   }
};

void merge(group *g2, group *g1)
{
    g1->end->next=g2->start;
    g1->end=g2->end;
    g1->value=g1->value+g2->value;
    g2->value=0;
    
}


void get2LeastIndexes(group *arr,unsigned int n,unsigned int *indexes)
{ 
   unsigned int least=arr[0].value;
   unsigned int index1=0,index2=0,i;
   for(i=1;i<n;i++)
   {
      if(arr[i].value<=least && arr[i].value>0)
      {
         least = arr[i].value;
         index2=index1;
         index1=i;
      }
   }
   
   least=-1;

   if(index1==index2)
   {
      for(i=0;i<n;i++)
      {
         if(arr[i].value<=least && i!=index1 && arr[i].value>0)
         {
            index1=i;
            least=arr[i].value; 
         }
      }
   }   
   indexes[0]=index1;
   indexes[1]=index2;
}


void generateCodes(unsigned int *arr,String *codes,int n)
{
   group *gp=new group[n];
   int j=0;
   for(int i=0;i<256;i++)
   {
      if(arr[i]>0)
      {
         gp[j++].add(&(codes[i]),arr[i]);
      }
   }
   
   for(int m=0;m<j;m++)
   {
      //cout<<gp[m].value<<"\t";
   }
   
   int k=0;
   unsigned int *indexes=new unsigned int[2];
   while(k<n-1)
   { 
     
        get2LeastIndexes(gp,n,indexes);
        gp[indexes[0]].append('0');
        gp[indexes[1]].append('1');
        gp[indexes[0]].display();
        gp[indexes[1]].display();
        k++;
        merge(&gp[indexes[0]],&gp[indexes[1]] );
   }
       gp[indexes[1]].append('\0'); 
   for(int i=0;i<256;i++)
   {
          strrev(codes[i].str);
   }
}
